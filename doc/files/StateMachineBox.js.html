<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>StateMachineBox.js - StateMachineBox</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="StateMachineBox" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/StateMachineBox.html">StateMachineBox</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: StateMachineBox.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// Generated by CoffeeScript 1.9.3
(function() {
  var DEBUG, SMB,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DEBUG = true;


  /**
  * @class StateMachineBox
  *
  * @constructor
  * @param stateMachineConfig {Object}
  * @param headline {String}
  * @param options {Object}
  *
   */

  window.StateMachineBox = (function() {

    /**
    * This property saves the currently active StateMachineBox instance.
    * @static
    * @protected
    * @property _activePopup
    * @type StateMachineBox
    *
     */
    var FADE_THROUGH;

    StateMachineBox._activePopup = null;


    /**
    * This property is the cache for all reused jquery elements.
    * @static
    * @protected
    * @property _$cache
    * @type Object
    *
     */

    StateMachineBox._$cache = {
      popup: $(&quot;&lt;div class=\&quot;smb\&quot;&gt;\n    &lt;div class=\&quot;positioner\&quot;&gt;\n        &lt;div class=\&quot;content\&quot;&gt;\n            &lt;div class=\&quot;loader\&quot; /&gt;\n            &lt;div class=\&quot;header\&quot;&gt;\n                &lt;div class=\&quot;headline smb_noselect\&quot; /&gt;\n            &lt;/div&gt;\n            &lt;div class=\&quot;bodyWrapper\&quot; /&gt;\n            &lt;div class=\&quot;fader\&quot; /&gt;\n            &lt;div class=\&quot;navigation\&quot; /&gt;\n            &lt;div class=\&quot;footer\&quot; /&gt;\n        &lt;/div&gt;\n        &lt;div class=\&quot;close\&quot; /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;&quot;),
      overlay: $(&quot;&lt;div class=\&quot;smb-overlay\&quot; /&gt;&quot;),
      buttons: {
        raw: $(&quot;&lt;div class=\&quot;button raw\&quot; /&gt;&quot;),
        ok: $(&quot;&lt;div class=\&quot;button ok\&quot; data-langkey=\&quot;ok\&quot; /&gt;&quot;),
        cancel: $(&quot;&lt;div class=\&quot;button cancel\&quot; data-langkey=\&quot;cancel\&quot; /&gt;&quot;),
        next: $(&quot;&lt;div class=\&quot;button next\&quot; data-langkey=\&quot;next\&quot; /&gt;&quot;),
        prev: $(&quot;&lt;div class=\&quot;button prev\&quot; data-langkey=\&quot;prev\&quot; /&gt;&quot;)
      }
    };

    if (DEBUG) {

      /**
      * This array lists all valid language keys.
      * Based on the ISO language codes (https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
      * @static
      * @protected
      * @property _languageKeys
      * @type Array
      *
       */
      StateMachineBox._languageKeys = [&quot;aa&quot;, &quot;ab&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;ak&quot;, &quot;am&quot;, &quot;an&quot;, &quot;ar&quot;, &quot;as&quot;, &quot;av&quot;, &quot;ay&quot;, &quot;az&quot;, &quot;ba&quot;, &quot;be&quot;, &quot;bg&quot;, &quot;bh&quot;, &quot;bi&quot;, &quot;bm&quot;, &quot;bn&quot;, &quot;bo&quot;, &quot;br&quot;, &quot;bs&quot;, &quot;ca&quot;, &quot;ce&quot;, &quot;ch&quot;, &quot;co&quot;, &quot;cr&quot;, &quot;cs&quot;, &quot;cu&quot;, &quot;cv&quot;, &quot;cy&quot;, &quot;da&quot;, &quot;de&quot;, &quot;dv&quot;, &quot;dz&quot;, &quot;ee&quot;, &quot;el&quot;, &quot;en&quot;, &quot;eo&quot;, &quot;es&quot;, &quot;et&quot;, &quot;eu&quot;, &quot;fa&quot;, &quot;ff&quot;, &quot;fi&quot;, &quot;fj&quot;, &quot;fo&quot;, &quot;fr&quot;, &quot;fy&quot;, &quot;ga&quot;, &quot;gd&quot;, &quot;gl&quot;, &quot;gn&quot;, &quot;gu&quot;, &quot;gv&quot;, &quot;ha&quot;, &quot;he&quot;, &quot;hi&quot;, &quot;ho&quot;, &quot;hr&quot;, &quot;ht&quot;, &quot;hu&quot;, &quot;hy&quot;, &quot;hz&quot;, &quot;ia&quot;, &quot;id&quot;, &quot;ie&quot;, &quot;ig&quot;, &quot;ii&quot;, &quot;ik&quot;, &quot;io&quot;, &quot;is&quot;, &quot;it&quot;, &quot;iu&quot;, &quot;ja&quot;, &quot;jv&quot;, &quot;ka&quot;, &quot;kg&quot;, &quot;ki&quot;, &quot;kj&quot;, &quot;kk&quot;, &quot;kl&quot;, &quot;km&quot;, &quot;kn&quot;, &quot;ko&quot;, &quot;kr&quot;, &quot;ks&quot;, &quot;ku&quot;, &quot;kv&quot;, &quot;kw&quot;, &quot;ky&quot;, &quot;la&quot;, &quot;lb&quot;, &quot;lg&quot;, &quot;li&quot;, &quot;ln&quot;, &quot;lo&quot;, &quot;lt&quot;, &quot;lu&quot;, &quot;lv&quot;, &quot;mg&quot;, &quot;mh&quot;, &quot;mi&quot;, &quot;mk&quot;, &quot;ml&quot;, &quot;mn&quot;, &quot;mr&quot;, &quot;ms&quot;, &quot;mt&quot;, &quot;my&quot;, &quot;na&quot;, &quot;nb&quot;, &quot;nd&quot;, &quot;ne&quot;, &quot;ng&quot;, &quot;nl&quot;, &quot;nn&quot;, &quot;no&quot;, &quot;nr&quot;, &quot;nv&quot;, &quot;ny&quot;, &quot;oc&quot;, &quot;oj&quot;, &quot;om&quot;, &quot;or&quot;, &quot;os&quot;, &quot;pa&quot;, &quot;pi&quot;, &quot;pl&quot;, &quot;ps&quot;, &quot;pt&quot;, &quot;qu&quot;, &quot;rm&quot;, &quot;rn&quot;, &quot;ro&quot;, &quot;ru&quot;, &quot;rw&quot;, &quot;sa&quot;, &quot;sc&quot;, &quot;sd&quot;, &quot;se&quot;, &quot;sg&quot;, &quot;si&quot;, &quot;sk&quot;, &quot;sl&quot;, &quot;sm&quot;, &quot;sn&quot;, &quot;so&quot;, &quot;sq&quot;, &quot;sr&quot;, &quot;ss&quot;, &quot;st&quot;, &quot;su&quot;, &quot;sv&quot;, &quot;sw&quot;, &quot;ta&quot;, &quot;te&quot;, &quot;tg&quot;, &quot;th&quot;, &quot;ti&quot;, &quot;tk&quot;, &quot;tl&quot;, &quot;tn&quot;, &quot;to&quot;, &quot;tr&quot;, &quot;ts&quot;, &quot;tt&quot;, &quot;tw&quot;, &quot;ty&quot;, &quot;ug&quot;, &quot;uk&quot;, &quot;ur&quot;, &quot;uz&quot;, &quot;ve&quot;, &quot;vi&quot;, &quot;vo&quot;, &quot;wa&quot;, &quot;wo&quot;, &quot;xh&quot;, &quot;yi&quot;, &quot;yo&quot;, &quot;za&quot;, &quot;zh&quot;, &quot;zu&quot;, &quot;en-gb&quot;, &quot;en-us&quot;, &quot;en-ca&quot;, &quot;en-au&quot;];

      /**
      * This array lists all locale keys.
      * @static
      * @protected
      * @property _localeKeys
      * @type Array
      *
       */
      StateMachineBox._localeKeys = [&quot;ok&quot;, &quot;cancel&quot;, &quot;next&quot;, &quot;prev&quot;];
    }


    /**
    * This array saves all instances of the StateMachineBox.
    * @static
    * @protected
    * @property _popups
    * @type Array
    *
     */

    StateMachineBox._popups = [];


    /**
    * This property defines the current theme of the StateMachineBox class.
    * @static
    * @protected
    * @property _theme
    * @type String
    * @default THEMES.DEFAULT
    *
     */

    StateMachineBox._theme = null;


    /**
    * This property defines what modes the StateMachineBox class can have.
    * @final
    * @static
    * @property MODES
    * @type Object
    *
     */

    StateMachineBox.MODES = {
      SINGLE: &quot;single&quot;,
      MANY: &quot;many&quot;
    };


    /**
    * This property saves the current mode of the StateMachineBox class.
    * @static
    * @property MODE
    * @type String
    * @default MODES.SINGLE
    *
     */

    StateMachineBox.MODE = null;


    /**
    * This property defines how fast fade-in and fade-out animations are.
    * @static
    * @property FADE_TIME
    * @type Number
    * @default 180
    *
     */

    StateMachineBox.FADE_TIME = 180;

    StateMachineBox.BUTTON_ACTIONS = {
      OK: &quot;CLOSE&quot;,
      CANCEL: &quot;CANCEL&quot;,
      NEXT: &quot;NEXT&quot;,
      PREV: &quot;PREV&quot;
    };

    StateMachineBox.BUTTONS = {
      OK: &quot;&lt;div class=\&quot;button ok locale\&quot; data-langkey=\&quot;ok\&quot; /&gt;&quot;,
      CANCEL: &quot;&lt;div class=\&quot;button cancel locale\&quot; data-langkey=\&quot;cancel\&quot; /&gt;&quot;,
      NEXT: &quot;&lt;div class=\&quot;button next locale\&quot; data-langkey=\&quot;next\&quot; /&gt;&quot;,
      PREV: &quot;&lt;div class=\&quot;button prev locale\&quot; data-langkey=\&quot;prev\&quot; /&gt;&quot;
    };

    StateMachineBox.ACTIONS = {
      CLOSE: function() {
        return this.close();
      },
      OK: function() {
        this.close(true);
        if (this.callbacks.onOk instanceof Function) {
          this.callbacks.onOk();
        }
        return this;
      },
      CANCEL: function() {
        this.close(true);
        if (this.callbacks.onCancel instanceof Function) {
          this.callbacks.onCancel();
        }
        return this;
      },
      CHANGE: function(targetState) {
        return this.change(targetState);
      },
      NEXT: function() {
        return this.next();
      },
      PREV: function() {
        return this.prev();
      }
    };

    StateMachineBox.BUTTON_COLORS = [&quot;#222222&quot;, &quot;#9FA39F&quot;, &quot;#B9BCB9&quot;, &quot;#D3D5D3&quot;];


    /**
    * This property defines all themes.
    * @static
    * @property THEMES
    * @type Object
    *
     */

    StateMachineBox.THEMES = {
      DEFAULT: &quot;smb-default&quot;
    };

    FADE_THROUGH = function(color, bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
      var self;
      self = this;
      fader.css(&quot;display&quot;, &quot;block&quot;).animate({
        &quot;background-color&quot;: color
      }, 200, &quot;swing&quot;, function() {
        return self.constructor.ANIMATIONS.NONE.call(self, bodyWrapper, body, fader, fromContent, toContent, event, from, to, function() {
          return fader.animate({
            &quot;background-color&quot;: &quot;transparent&quot;
          }, 200, &quot;swing&quot;, function() {
            fader.css(&quot;display&quot;, &quot;none&quot;);
            if (typeof callback === &quot;function&quot;) {
              callback();
            }
            return true;
          });
        });
      });
      return true;
    };

    FADE_THROUGH.COLOR = function(color) {
      return function(bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
        return FADE_THROUGH.call(this, color, bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback);
      };
    };

    FADE_THROUGH.WHITE = FADE_THROUGH.COLOR(&quot;#ffffff&quot;);

    FADE_THROUGH.BLACK = FADE_THROUGH.COLOR(&quot;#000000&quot;);

    FADE_THROUGH.THEME = function(bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
      var self;
      self = this;
      fader.css({
        display: &quot;block&quot;,
        opacity: 0
      }).animate({
        opacity: 1
      }, 200, &quot;swing&quot;, function() {
        return self.constructor.ANIMATIONS.NONE.call(self, bodyWrapper, body, fader, fromContent, toContent, event, from, to, function() {
          return fader.animate({
            opacity: 0
          }, 200, &quot;swing&quot;, function() {
            fader.css(&quot;display&quot;, &quot;none&quot;);
            if (typeof callback === &quot;function&quot;) {
              callback();
            }
            return true;
          });
        });
      });
      return true;
    };

    StateMachineBox.ANIMATIONS = {
      SLIDE: function(bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
        body.append(toContent);
        if (event === &quot;back&quot;) {
          bodyWrapper.prepend(body).css(&quot;margin-left&quot;, &quot;-&quot; + this.bodyWidth + &quot;px&quot;).animate({
            &quot;margin-left&quot;: &quot;0px&quot;
          }, 400, &quot;swing&quot;, function() {
            $(this).children().eq(1).detach();
            if (typeof callback === &quot;function&quot;) {
              callback();
            }
            return true;
          });
        } else if (from !== &quot;none&quot;) {
          bodyWrapper.append(body).animate({
            &quot;margin-left&quot;: &quot;-&quot; + this.bodyWidth + &quot;px&quot;
          }, 400, &quot;swing&quot;, function() {
            $(this).children().eq(0).detach();
            $(this).css(&quot;margin-left&quot;, &quot;0px&quot;);
            if (typeof callback === &quot;function&quot;) {
              callback();
            }
            return true;
          });
        }
        return true;
      },
      FADE: function(bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
        return true;
      },
      FADE_THROUGH: FADE_THROUGH,
      NONE: function(bodyWrapper, body, fader, fromContent, toContent, event, from, to, callback) {
        body.append(toContent);
        bodyWrapper.find(&quot;.body&quot;).detach();
        bodyWrapper.append(body);
        if (typeof callback === &quot;function&quot;) {
          callback();
        }
        return true;
      }
    };

    StateMachineBox.locale = {};


    /**
    * This method initializes the StateMachineBox class. For example the default locales are set.
    * @static
    * @public
    * @method init
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.init = function() {
      this._theme = this.THEMES.DEFAULT;
      this.ANIMATIONS.DEFAULT = this.ANIMATIONS.SLIDE;
      this.MODE = this.MODES.SINGLE;
      this.setLocale(&quot;en&quot;, {
        ok: &quot;ok&quot;,
        cancel: &quot;cancel&quot;,
        next: &quot;next&quot;,
        prev: &quot;previous&quot;
      });
      this.setLocale(&quot;de&quot;, {
        ok: &quot;ok&quot;,
        cancel: &quot;abbrechen&quot;,
        next: &quot;weiter&quot;,
        prev: &quot;zur√ºck&quot;
      });
      return this;
    };


    /**
    * This method finds out which StateMachineBox instance is the front most.
    * It doesn&#x27;t work if custom styles or css classes are set.
    * @static
    * @public
    * @method getTopMost
    * @return {StateMachineBox}
    *
     */

    StateMachineBox.getTopMost = function() {
      var divs, j, len, popup, popups;
      popups = this._popups;
      divs = $();
      for (j = 0, len = popups.length; j &lt; len; j++) {
        popup = popups[j];
        divs = divs.add(popup.div);
      }
      return popups[divs.index(divs.filter(&quot;:visible:last&quot;))] || null;
    };


    /**
    * This method finds out which StateMachineBox instance is the front most.
    * It doesn&#x27;t work if custom styles or css classes are set.
    * @static
    * @protected
    * @method getTopMost
    * @param popup {StateMachineBox}
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox._setActive = function(popup) {
      this._activePopup = popup;
      return this;
    };


    /**
    * This method returns the active StateMachineBox instance or the front most (if none are active).
    * @static
    * @protected
    * @method getActive
    * @return {StateMachineBox}
    *
     */

    StateMachineBox.getActive = function() {
      return this._activePopup || this.getTopMost();
    };


    /**
    * This method sets the locale information for a specific language. This information will be updated in all StateMachineBox&#x27;es by default.
    * @static
    * @protected
    * @method setLocale
    * @param language {String}
    * @param values {Object}
    * This object should have a key for each element in StateMachineBox._localeKeys. Errors depend on debug mode.
    * @param redraw {Boolean}
    * Optional. Default is true. If not true no instance of StateMachineBox will be updated.
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.setLocale = function(language, values, redraw) {
      var j, k, key, l, len, len1, len2, popup, ref, ref1, ref2;
      if (redraw == null) {
        redraw = true;
      }
      if (DEBUG) {
        if (indexOf.call(this._languageKeys, language) &gt;= 0) {
          ref = this._localeKeys;
          for (j = 0, len = ref.length; j &lt; len; j++) {
            key = ref[j];
            if (values[key] == null) {
              throw new Error(&quot;StateMachineBox.setLocale: Missing at least 1 key &#x27;&quot; + key + &quot;&#x27; for locale settings!&quot;);
            }
          }
          this.locale[language] = values;
          if (redraw === true) {
            ref1 = this._popups;
            for (k = 0, len1 = ref1.length; k &lt; len1; k++) {
              popup = ref1[k];
              popup.redraw();
            }
          }
          return this;
        }
        throw new Error(&quot;StateMachineBox.setLocale: Invalid language &#x27;&quot; + language + &quot;&#x27; given!&quot;);
      }
      this.locale[language] = values;
      if (redraw === true) {
        ref2 = this._popups;
        for (l = 0, len2 = ref2.length; l &lt; len2; l++) {
          popup = ref2[l];
          popup.redraw();
        }
      }
      return this;
    };


    /**
    * This method gets the locale value for a given language and and a given key. If no key is specified this method returns the data object for the given language.
    * @static
    * @protected
    * @method getLocale
    * @param language {String}
    * @param key {String}
    * Optional. Default resolves to all data. If given should match a key in StateMachineBox._languageKeys.
    * @return {String}
    *
     */

    StateMachineBox.getLocale = function(language, key) {
      var ref;
      if (DEBUG) {
        if (((ref = this.locale[language]) != null ? ref[key] : void 0) != null) {
          return this.locale[language][key];
        }
        if ((key == null) &amp;&amp; (this.locale[language] != null)) {
          console.info(&quot;StateMachineBox.getLocale: No key given. Returning all keys for &#x27;&quot; + language + &quot;&#x27;.&quot;);
          return this.locale[language];
        }
        throw new Error(&quot;StateMachineBox.getLocale: language &#x27;&quot; + language + &quot;&#x27; not set or key &#x27;&quot; + key + &quot;&#x27; not found!&quot;);
      }
      if (key != null) {
        return this.locale[language][key] || null;
      }
      return this.locale[language];
    };


    /**
    * This method can be used to remove unneeded locale data from the memory.
    * @static
    * @method deleteLocale
    * @param language {String}
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.deleteLocale = function(language) {
      if (DEBUG) {
        if (this.locale[language] != null) {
          delete this.locale[language];
        } else {
          console.warn(&quot;StateMachineBox.deleteLocale: language &#x27;&quot; + language + &quot;&#x27; not set thus can&#x27;t be deleted!&quot;);
        }
        return this;
      }
      delete this.locale[language];
      return this;
    };

    StateMachineBox.addTheme = function(theme) {
      if (DEBUG) {
        if (this.THEMES[theme] == null) {
          if (theme !== theme.toUpperCase()) {
            console.warn(&quot;StateMachineBox.addTheme: For consistency it is recommended to use upper case theme names. Theme &#x27;&quot; + theme + &quot;&#x27; will be set anyways.&quot;);
          }
          this.THEMES[theme] = theme;
        }
        throw new Error(&quot;StateMachineBox.addTheme: Theme &#x27;&quot; + theme + &quot;&#x27; already exists!&quot;);
      }
      this.THEMES[theme] = theme;
      return this;
    };

    StateMachineBox.setTheme = function(theme, redraw) {
      var j, k, len, len1, popup, ref, ref1;
      if (redraw == null) {
        redraw = true;
      }
      if (DEBUG) {
        if (this.THEMES[theme] != null) {
          this._theme = this.THEMES[theme];
          if (redraw === true) {
            ref = this._popups;
            for (j = 0, len = ref.length; j &lt; len; j++) {
              popup = ref[j];
              popup.setTheme(this._theme);
            }
          }
          return this;
        }
        throw new Error(&quot;StateMachineBox.setTheme: Invalid theme &#x27;&quot; + theme + &quot;&#x27; given!&quot;);
      }
      this._theme = this.THEMES[theme];
      if (redraw === true) {
        ref1 = this._popups;
        for (k = 0, len1 = ref1.length; k &lt; len1; k++) {
          popup = ref1[k];
          popup.setTheme(this._theme);
        }
      }
      return this;
    };


    /**
    * This method can be used to add a StateMachineBox to the list of registered instances.
    * @static
    * @protected
    * @method _registerPopup
    * @param popup {StateMachineBox}
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox._registerPopup = function(popup) {
      if (indexOf.call(this._popups, popup) &lt; 0) {
        this._popups.push(popup);
      }
      return this;
    };


    /**
    * This method can be used to remove a StateMachineBox from the list of registered instances.
    * @static
    * @protected
    * @method _unregisterPopup
    * @param popup {StateMachineBox}
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox._unregisterPopup = function(popup) {
      var i, p;
      this._popups = (function() {
        var j, len, ref, results;
        ref = this._popups;
        results = [];
        for (i = j = 0, len = ref.length; j &lt; len; i = ++j) {
          p = ref[i];
          if (p !== popup) {
            results.push(p);
          }
        }
        return results;
      }).call(this);
      return this;
    };

    StateMachineBox[&quot;new&quot;] = function(stateMachineConfig, headline, options) {
      if (options == null) {
        options = {};
      }
      return new this(stateMachineConfig, headline, options);
    };

    function StateMachineBox(stateMachineConfig, headline, options) {
      var CLASS, callback, callbackName, css, event, height, j, k, len, len1, ref, ref1, ref2, self, width;
      if (options == null) {
        options = {};
      }
      if (DEBUG) {
        if ((stateMachineConfig == null) || (stateMachineConfig.events == null)) {
          throw new Error(&quot;StateMachineBox::constructor: No (valid) state machine configuration given!&quot;);
        }
        ref = stateMachineConfig.events;
        for (j = 0, len = ref.length; j &lt; len; j++) {
          event = ref[j];
          if (this[event.name] != null) {
            throw new Error(&quot;StateMachineBox::constructor: Trying to create event &#x27;&quot; + event.name + &quot;&#x27; but that property already exists in popup!!&quot;);
          }
        }
        ref1 = stateMachineConfig.callbacks;
        for (callbackName in ref1) {
          callback = ref1[callbackName];
          if (this[callbackName] != null) {
            throw new Error(&quot;StateMachineBox::constructor: Trying to create callback &#x27;&quot; + callbackName + &quot;&#x27; but that property already exists in popup!!&quot;);
          }
        }
      }
      CLASS = this.constructor;
      this.headline = headline;
      this.options = options;
      this.closeButtonAction = options.closeButtonAction || &quot;close&quot;;
      this.callbacks = options.callbacks || {};
      this.theme = options.theme || CLASS.THEMES.DEFAULT;
      this.locale = options.locale || &quot;en&quot;;
      this.showNavigation = options.showNavigation || false;
      this.container = options.container || $(document.body);
      this._animate = options.animation || CLASS.ANIMATIONS.DEFAULT;
      this.data = {
        eventPath: []
      };
      this._drawn = false;
      this._active = false;
      this.div = CLASS._$cache.popup.clone().addClass(this.theme);
      this.overlay = CLASS._$cache.overlay.clone().addClass(this.theme);
      this.bodyWrapper = this.div.find(&quot;.bodyWrapper&quot;);
      this.fader = this.div.find(&quot;.fader&quot;);
      this.navigation = this.div.find(&quot;.navigation&quot;);
      this.loader = this.div.find(&quot;.loader&quot;);
      this.footer = this.div.find(&quot;.footer&quot;);
      css = {};
      if (((width = options.width) != null) &amp;&amp; ((height = options.height) != null)) {
        width = parseInt(width, 10);
        height = parseInt(height, 10);
        if (isNaN(width)) {
          css.width = &quot;auto&quot;;
        } else {
          css.width = width + &quot;px&quot;;
        }
        if (isNaN(height)) {
          css.height = &quot;auto&quot;;
        } else {
          css.height = height + &quot;px&quot;;
        }
      }
      if (!options.left) {
        if ((css.width != null) &amp;&amp; css.width !== &quot;auto&quot;) {
          css.left = &quot;calc(50% - &quot; + (width / 2) + &quot;px)&quot;;
        }
      }
      if (!options.top) {
        if ((css.height != null) &amp;&amp; css.height !== &quot;auto&quot;) {
          css.top = &quot;calc(50% - &quot; + (height / 2) + &quot;px)&quot;;
        }
      }
      this.div.css(css);
      this.bodyWidth = parseFloat(this.options.width) || 800;
      this.bodyPadding = {
        top: 10,
        right: 40,
        bottom: 10,
        left: 40
      };
      this.stateMachineConfig = stateMachineConfig;
      this.contents = {};
      ref2 = stateMachineConfig.events;
      for (k = 0, len1 = ref2.length; k &lt; len1; k++) {
        event = ref2[k];
        if (event.content != null) {
          this.contents[event.to] = event.content;
        }
      }
      self = this;
      if (stateMachineConfig.callbacks == null) {
        stateMachineConfig.callbacks = {};
      }
      stateMachineConfig.callbacks.onenterstate = function() {
        var event, from, params, to;
        event = arguments[0], from = arguments[1], to = arguments[2], params = 4 &lt;= arguments.length ? slice.call(arguments, 3) : [];
        console.log(&quot;onenterstate&quot;, arguments);
        if (self.beforeChange instanceof Function &amp;&amp; self.beforeChange(to) === false) {
          return false;
        }
        self._changeContent(event, from, to);
        self.data.eventPath.push(event);
        if (typeof self.onChange === &quot;function&quot;) {
          self.onChange(event, from, to);
        }
        return true;
      };
      stateMachineConfig.target = this;
      StateMachine.create(stateMachineConfig);
      CLASS._registerPopup(this);
    }


    /**
    * This method hides the instance&#x27;s ajax loader.
    * @protected
    * @method _changeContent
    * @param event {String}
    * The name of the event which causes the content to change.
    * @param from {String}
    * The name of the state that we&#x27;re coming from.
    * @param to {String}
    * The name of the state that we&#x27;re going to.
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype._changeContent = function(event, from, to) {
      var body, content;
      content = this.contents[to];
      if (content == null) {
        if (DEBUG) {
          throw new Error(&quot;StateMachineBox::_changeContent: No content given for &#x27;&quot; + to + &quot;&#x27;!&quot;);
        }
        return this;
      }
      body = $(&quot;&lt;div class=\&quot;body\&quot; style=\&quot;width: &quot; + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + &quot;px;\&quot; /&gt;&quot;);
      this._animate(this.bodyWrapper, body, this.fader, this.contents[this.current], content, event, from, to, this.callbacks.onAnimate);
      return this;
    };


    /**
    * This method sets the current StateMachineBox instance as currently active.
    * @protected
    * @method _setAsActive
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype._setAsActive = function() {
      this.constructor._setActive(this);
      return this;
    };


    /**
    * This method show the instance&#x27;s div.
    * @method show
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.show = function(callback) {
      this.div.fadeIn(this.constructor.FADE_TIME, callback);
      return this;
    };


    /**
    * This method hides the instance&#x27;s div.
    * @method hide
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.hide = function(callback) {
      this.div.fadeOut(this.constructor.FADE_TIME, callback);
      return this;
    };


    /**
    * This method shows the instance&#x27;s overlay.
    * @method showOverlay
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.showOverlay = function(callback) {
      this.overlay.fadeIn(this.constructor.FADE_TIME, callback);
      return this;
    };


    /**
    * This method hides the instance&#x27;s overlay.
    * @method hideOverlay
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.hideOverlay = function(callback) {
      this.overlay.fadeOut(this.constructor.FADE_TIME, callback);
      return this;
    };


    /**
    * This method shows the instance&#x27;s ajax loader.
    * @method showLoader
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.showLoader = function() {
      this.loader.fadeIn(this.constructor.FADE_TIME);
      return this;
    };


    /**
    * This method hides the instance&#x27;s ajax loader.
    * @method hideLoader
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.hideLoader = function() {
      this.loader.fadeOut(this.constructor.FADE_TIME);
      return this;
    };


    /**
    * This method triggers an action (one of StateMachineBox.ACTIONS).
    * Those actions are a subset of all events.
    * @method fireAction
    * @param name {string}
    * The name of the action.
    * @param params... {mixed}
    * Optional. Any parameter will be passed to the action.
    * @return {mixed}
    *
     */

    StateMachineBox.prototype.fireAction = function() {
      var action, name, params;
      name = arguments[0], params = 2 &lt;= arguments.length ? slice.call(arguments, 1) : [];
      name = name.toUpperCase();
      if ((action = this.constructor.ACTIONS[name]) != null) {
        return action.apply(this, params);
      }
      if (DEBUG) {
        throw new Error(&quot;Popup::fireAction: No action with name &#x27;&quot; + name + &quot;&#x27; found!&quot;);
      }
      return null;
    };


    /**
    * This method hides the instance&#x27;s ajax loader.
    * @method close
    * @param ignoreCallback {Boolean}
    * Optional. Default is false. Indicates if the beforeClose and onClose callbacks will be called.
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.close = function(ignoreCallback) {
      var base, self;
      if (ignoreCallback == null) {
        ignoreCallback = false;
      }
      if (!ignoreCallback &amp;&amp; this.beforeClose instanceof Function &amp;&amp; this.beforeClose() === false) {
        return false;
      }
      self = this;
      this.hide(function() {
        self.div.remove();
        return true;
      });
      this.hideOverlay(function() {
        self.overlay.remove();
        return true;
      });
      this.constructor._unregisterPopup(this);
      if (!ignoreCallback) {
        if (typeof (base = this.callbacks).onClose === &quot;function&quot;) {
          base.onClose();
        }
      }
      return this;
    };


    /**
    * Synonym for close.
    * @method remove
    *
     */

    StateMachineBox.prototype.remove = function() {
      return this.close.apply(this, arguments);
    };


    /**
    * This method returns the content associated with the current state.
    * @method currentContent
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.currentContent = function() {
      return this.contents[this.current];
    };

    StateMachineBox.prototype.getLocale = function(key) {
      return this.constructor.getLocale(this.locale, key);
    };


    /**
    * This method draws the StateMachineBox instance to the DOM.
    * @method draw
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.draw = function() {
      var action, b, body, button, buttons, content, event, eventName, idx, j, lastColor, len, self;
      if (this.constructor.MODE === this.constructor.MODES.SINGLE &amp;&amp; (this.constructor.getActive() != null)) {
        console.warn(&quot;Popup::draw: tried to draw more than 1 popup but mode is set to &#x27;single&#x27;!&quot;);
        return this;
      }
      if (this._drawn === true) {
        console.warn(&quot;Popup::draw: tried to draw same StateMachineBox instance more than once!&quot;);
        return this;
      }
      self = this;
      this.div.find(&quot;.headline&quot;).append(this.headline);
      this.div.find(&quot;.overlay, .close&quot;).click(function() {
        self.fireAction(self.closeButtonAction);
        return true;
      });
      this.div.mousedown(function() {
        self._setAsActive();
        return true;
      });
      buttons = this.options.buttons || [];
      for (idx = j = 0, len = buttons.length; j &lt; len; idx = ++j) {
        button = buttons[idx];
        if (!(button != null)) {
          continue;
        }
        action = null;
        if (typeof button === &quot;string&quot;) {
          b = button.toLowerCase();
          button = this.constructor._$cache.buttons[b].clone();
          event = this.constructor.ACTIONS[this.constructor.BUTTON_ACTIONS[b]];
          eventName = b;
        } else if ((button.button != null) &amp;&amp; (button.action != null)) {
          b = button;
          button = this.constructor._$cache.buttons[b.button.toLowerCase()].clone();
          event = this.constructor.ACTIONS[b.action.toLowerCase()];
          eventName = b.action.toLowerCase();
        } else if ((button.event != null) &amp;&amp; (button.label != null)) {
          if (DEBUG) {
            if (this[button.event] == null) {
              console.warn(&quot;StateMachineBox::draw: Invalid button configuration for StateMachineBox! Invalid button event &#x27;&quot; + eventName + &quot;&#x27;!&quot;, this.options.buttons);
              continue;
            }
          }
          b = button;
          button = this.constructor._$cache.buttons.raw.clone();
          if (b.locale === true) {
            button.text(this.getLocale(b.label));
          } else {
            button.text(b.label);
          }
          event = this[b.event];
          eventName = b.event;
        } else if (DEBUG) {
          button = null;
        }
        if (DEBUG) {
          if (button == null) {
            console.warn(&quot;StateMachineBox::draw: Invalid button configuration for StateMachineBox!&quot;, this.options.buttons);
            continue;
          }
        }
        if (event != null) {
          lastColor = this.constructor.BUTTON_COLORS[idx];
          button.css({
            &quot;background-color&quot;: lastColor
          });
          (function(eventName) {
            return button.click(function() {
              self.fireEvent(eventName);
              return true;
            });
          })(eventName);
          this.footer.append(button);
        }
      }
      this.footer.css(&quot;background-color&quot;, lastColor);
      self = this;
      if (!this.showNavigation) {
        this.navigation.addClass(&quot;hidden&quot;);
      }
      this.init();
      content = this.contents[this.current];
      if (content == null) {
        throw new Error(&quot;StateMachineBox::draw: No content found for &#x27;&quot; + this.current + &quot;&#x27;!&quot;);
      }
      body = $(&quot;&lt;div class=\&quot;body\&quot; style=\&quot;width: &quot; + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + &quot;px;\&quot; /&gt;&quot;);
      body.append(content);
      this.bodyWrapper.append(body);
      if (this.constructor.MODE === this.constructor.MODES.MANY) {
        this.div.draggable({
          handle: &quot;.header&quot;
        }).addClass(&quot;draggable&quot;);
      } else if (this.constructor.MODE === this.constructor.MODES.SINGLE) {
        this.container.append(this.overlay.click(function() {
          self.fireAction(&quot;cancel&quot;);
          return true;
        }));
      }
      this.container.append(this.div);
      this._setAsActive();
      return this;
    };


    /**
    * This method redraws the StateMachineBox instance.
    * This does not actually redraw everything but resets the texts of elements containing locale data.
    * @method redraw
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.redraw = function() {
      var elems, key, ref, val;
      elems = this.div.find(&quot;.locale&quot;);
      ref = this.contructor.getLocale(this.locale);
      for (key in ref) {
        val = ref[key];
        elems.filter(&quot;[data-langkey=\&quot;&quot; + key + &quot;\&quot;]&quot;).text(val);
      }
      return this;
    };


    /**
    * This method redraws the StateMachineBox instance.
    * This does not actually redraw everything but resets the theme css classes of the according elements.
    * @method redraw
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.setTheme = function(theme) {
      if (this.theme !== theme) {
        this.div.find(&quot;.&quot; + this.theme).removeClass(this.theme).addClass(theme);
      }
      return this;
    };


    /**
    * This method triggers an event. If the event is invalid for the current state onFailure will be called.
    * This method might seem a bit unnecessary but implicit event function calls might appear weird and this method has better error reporting.
    * @method fireEvent
    * @param name {String}
    * The name of the event to trigger.
    * @param params... {mixed}
    * Optional. Any parameter will be passed to the event callback.
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.fireEvent = function() {
      var base, e, name, params;
      name = arguments[0], params = 2 &lt;= arguments.length ? slice.call(arguments, 1) : [];
      if (this[name] instanceof Function) {
        if (DEBUG) {
          try {
            this[name].apply(this, params);
          } catch (_error) {
            e = _error;
            console.warn(&quot;StateStatePopup::fireEvent: Event &#x27;&quot; + name + &quot;&#x27; is invalid for current state!&quot;);
            throw e;
          } finally {
            return this;
          }
        }
        this[name].apply(this, params);
        return this;
      }
      console.warn(&quot;StateStatePopup::fireEvent: There is no event called &#x27;&quot; + name + &quot;&#x27;! Use onFailure() to catch that!&quot;);
      if (typeof (base = this.callbacks).onFailure === &quot;function&quot;) {
        base.onFailure(name);
      }
      return this;
    };


    /**
    * This method is a convenience method for fireEvent. If the state allows only 1 event this method will trigger that event.
    * @method next
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.next = function() {
      var base, base1, event, foundEvents, j, len, ref;
      if (this.beforeNext instanceof Function &amp;&amp; this.beforeNext() === false) {
        return this;
      }
      foundEvents = [];
      ref = this.stateMachineConfig.events;
      for (j = 0, len = ref.length; j &lt; len; j++) {
        event = ref[j];
        if (event.from === this.current &amp;&amp; event.name !== &quot;back&quot;) {
          foundEvents.push(event);
        }
      }
      if (foundEvents.length === 1) {
        this.fireEvent(foundEvents.first.name);
        return this;
      }
      if (foundEvents.length === 0) {
        console.warn(&quot;StateMachineBox::next: There is no event for &#x27;&quot; + this.current + &quot;&#x27;! Can&#x27;t go any further! Use onFailure() to catch that!&quot;);
        if (typeof (base = this.callbacks).onFailure === &quot;function&quot;) {
          base.onFailure(&quot;next&quot;);
        }
        return this;
      }
      console.warn(&quot;StateMachineBox::next: More than 1 event for &#x27;&quot; + this.current + &quot;&#x27;: [&quot; + ((function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = foundEvents.length; k &lt; len1; k++) {
          event = foundEvents[k];
          results.push(event.name);
        }
        return results;
      })()) + &quot;]! Can&#x27;t decide where to go! Use onFailure() to catch that!&quot;);
      if (typeof (base1 = this.callbacks).onFailure === &quot;function&quot;) {
        base1.onFailure(&quot;next&quot;);
      }
      return this;
    };


    /**
    * This method is a convenience method for fireEvent (just like next). The difference here is that the state machine has no direction so next and prev are indistinguishable. Therefore the state machine must have a &#x27;back&#x27; event for all states that are supposed to allow prev.
    * Only if there is exactly 1 other state that has an event that changes to the current state, prev can be applied.
    * @method prev
    * @return {StateMachineBox}
    * @chainable
    *
     */

    StateMachineBox.prototype.prev = function() {
      var base, e;
      if (this.beforePrev instanceof Function &amp;&amp; this.beforePrev() === false) {
        return this;
      }
      try {
        this.back();
        return this;
      } catch (_error) {
        e = _error;
        console.warn(&quot;StateMachineBox::prev: Cannot go to &#x27;prev&#x27; because no back route was defined! Define it with &#x27;{ name: &#x27;back&#x27;, from: &#x27;prevState&#x27;, to: &#x27;returnState&#x27; }&#x27; ;) Use onFailure() to catch that!&quot;);
        console.warn(e);
        if (typeof (base = this.callbacks).onFailure === &quot;function&quot;) {
          base.onFailure(&quot;prev&quot;);
        }
        return this;
      }
    };

    return StateMachineBox;

  })();

  StateMachineBox.init();

  SMB = (function(superClass) {
    extend(SMB, superClass);

    function SMB() {
      return SMB.__super__.constructor.apply(this, arguments);
    }

    return SMB;

  })(StateMachineBox);

}).call(this);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
