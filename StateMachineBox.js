// Generated by CoffeeScript 1.9.3
(function() {
  var DEBUG, SMB,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DEBUG = true;

  window.StateMachineBox = (function() {
    var FADE_TIME;

    StateMachineBox.MODES = {
      SINGLE: "single",
      MANY: "many"
    };

    StateMachineBox.MODE = StateMachineBox.MODES.SINGLE;

    StateMachineBox.FADE_TIME = 180;

    FADE_TIME = StateMachineBox.FADE_TIME;

    StateMachineBox.BUTTON_ACTIONS = {
      OK: "CLOSE",
      CANCEL: "CANCEL",
      NEXT: "NEXT",
      PREV: "PREV"
    };

    StateMachineBox.BUTTONS = {
      OK: "<div class=\"button ok\">ok</div>",
      CANCEL: "<div class=\"button cancel\">cancel</div>",
      NEXT: "<div class=\"button next\">next</div>",
      PREV: "<div class=\"button prev\">prev</div>"
    };

    StateMachineBox.ACTIONS = {
      CLOSE: function() {
        return this.close();
      },
      OK: function() {
        this.close(true);
        if (this.onOk instanceof Function) {
          this.onOk();
        }
        return this;
      },
      CANCEL: function() {
        this.close(true);
        if (this.onCancel instanceof Function) {
          this.onCancel();
        }
        return this;
      },
      CHANGE: function(idx) {
        return this.change(idx);
      },
      NEXT: function() {
        return this.next();
      },
      PREV: function() {
        return this.prev();
      }
    };

    StateMachineBox.BUTTON_COLORS = ["#222222", "#9FA39F", "#B9BCB9", "#D3D5D3"];

    StateMachineBox._popups = [];

    StateMachineBox._activePopup = null;

    StateMachineBox.getTopMost = function() {
      var divs, j, len, popup, popups;
      popups = this._popups;
      divs = $();
      for (j = 0, len = popups.length; j < len; j++) {
        popup = popups[j];
        divs = divs.add(popup.div);
      }
      return popups[divs.index(divs.filter(":visible:last"))] || null;
    };

    StateMachineBox._setActive = function(popup) {
      this._activePopup = popup;
      return this;
    };

    StateMachineBox.getActive = function() {
      return this._activePopup || this.getTopMost();
    };

    StateMachineBox.registerPopup = function(popup) {
      if (indexOf.call(this._popups, popup) < 0) {
        this._popups.push(popup);
      }
      return this;
    };

    StateMachineBox.unregisterPopup = function(popup) {
      var i, p;
      this._popups = (function() {
        var j, len, ref, results;
        ref = this._popups;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          p = ref[i];
          if (p !== popup) {
            results.push(p);
          }
        }
        return results;
      }).call(this);
      return this;
    };

    function StateMachineBox(stateMachineConfig, headline, options) {
      var callback, callbackName, event, j, k, len, len1, ref, ref1, ref2, self;
      if (options == null) {
        options = {};
      }
      if (DEBUG) {
        if ((stateMachineConfig == null) || (stateMachineConfig.events == null)) {
          throw new Error("StatePopup::constructor: No (valid) state machine configuration given!");
        }
        ref = stateMachineConfig.events;
        for (j = 0, len = ref.length; j < len; j++) {
          event = ref[j];
          if (this[event.name] != null) {
            throw new Error("StatePopup::constructor: Trying to create event '" + event.name + "' but that property already exists in popup!!");
          }
        }
        ref1 = stateMachineConfig.callbacks;
        for (callbackName in ref1) {
          callback = ref1[callbackName];
          if (this[callbackName] != null) {
            throw new Error("StatePopup::constructor: Trying to create callback '" + callbackName + "' but that property already exists in popup!!");
          }
        }
      }
      this.headline = headline;
      this.options = options;
      this.closeButtonAction = options.closeButtonAction || "close";
      this.onClose = options.onClose;
      this.onOk = options.onOk;
      this.onCancel = options.onCancel;
      this.onNext = options.onNext;
      this.onPrev = options.onPrev;
      this.onChange = options.onChange;
      this.beforeClose = options.beforeClose;
      this.beforeNext = options.beforeNext;
      this.beforePrev = options.beforePrev;
      this.beforeChange = options.beforeChange;
      this.onFailure = options.onFailure;
      this.data = {};
      this.div = $("<div class=\"popup onTop\" />");
      this.overlay = $("<div class=\"popup overlay onTop\" />");
      if ((options.width != null) && (options.height != null)) {
        this.div.css({
          width: options.width,
          height: options.height
        });
      }
      this.loader = null;
      this.bodyWidth = parseFloat(this.options.width) || 800;
      this.bodyPadding = {
        top: 10,
        right: 40,
        bottom: 10,
        left: 40
      };
      this._active = false;
      stateMachineConfig.target = this;
      if (stateMachineConfig.linearization != null) {
        this.linearization = stateMachineConfig.linearization;
      } else {
        this.linearization = null;
      }
      this.stateMachineConfig = stateMachineConfig;
      this.bodyWrapper = null;
      this.contents = {};
      ref2 = stateMachineConfig.events;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        event = ref2[k];
        if (event.content != null) {
          this.contents[event.to] = event.content;
        }
      }
      self = this;
      if (stateMachineConfig.callbacks == null) {
        stateMachineConfig.callbacks = {};
      }
      stateMachineConfig.callbacks.onenterstate = function() {
        var event, from, params, to;
        event = arguments[0], from = arguments[1], to = arguments[2], params = 4 <= arguments.length ? slice.call(arguments, 3) : [];
        console.log("onenterstate", arguments);
        if (self.beforeChange instanceof Function && self.beforeChange(to) === false) {
          return false;
        }
        self.changeContent(event, from, to);
        return true;
      };
      StateMachine.create(stateMachineConfig);
      this.constructor.registerPopup(this);
    }

    StateMachineBox.prototype._setAsActive = function() {
      this.constructor._setActive(this);
      return this;
    };

    StateMachineBox.prototype.show = function(callback) {
      this.div.fadeIn(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.hide = function(callback) {
      this.div.fadeOut(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.showOverlay = function(callback) {
      this.overlay.fadeIn(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.hideOverlay = function(callback) {
      this.overlay.fadeOut(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.showLoader = function() {
      this.loader.fadeIn(FADE_TIME);
      return this;
    };

    StateMachineBox.prototype.hideLoader = function() {
      this.loader.fadeOut(FADE_TIME);
      return this;
    };

    StateMachineBox.prototype.fireAction = function() {
      var action, name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      name = name.toUpperCase();
      if ((action = this.constructor.ACTIONS[name]) != null) {
        return action.apply(this, params);
      }
      throw new Error("Popup::fireAction: No action with name '" + name + "' found!");
    };

    StateMachineBox.prototype.close = function(ignoreCallback) {
      var self;
      if (ignoreCallback == null) {
        ignoreCallback = false;
      }
      if (!ignoreCallback && this.beforeClose instanceof Function && this.beforeClose() === false) {
        return false;
      }
      self = this;
      this.hide(function() {
        self.div.remove();
        return true;
      });
      this.hideOverlay(function() {
        self.overlay.remove();
        return true;
      });
      this.constructor.unregisterPopup(this);
      if (!ignoreCallback) {
        if (typeof this.onClose === "function") {
          this.onClose();
        }
      }
      return this;
    };

    StateMachineBox.prototype.remove = function() {
      return this.close.apply(this, arguments);
    };

    StateMachineBox.prototype.changeContent = function(event, from, to) {
      var body, content;
      body = $("<div class=\"body\" style=\"width: " + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + "px;\" />");
      content = this.contents[to];
      if (content == null) {
        throw new Error("StatePopup::changeContent: No content given for '" + to + "'!");
      }
      if (this.bodyWrapper == null) {
        this.bodyWrapper = this.div.find(".bodyWrapper");
      }
      body.append(content);
      if (event === "back") {
        this.bodyWrapper.prepend(body).css("margin-left", "-" + this.bodyWidth + "px").animate({
          "margin-left": "0px"
        }, 400, "swing", function() {
          $(this).children().eq(1).detach();
          return true;
        });
      } else if (from !== "none") {
        this.bodyWrapper.append(body).animate({
          "margin-left": "-" + this.bodyWidth + "px"
        }, 400, "swing", function() {
          $(this).children().eq(0).detach();
          $(this).css("margin-left", "0px");
          return true;
        });
      }
      return this;
    };

    StateMachineBox.prototype.currentContent = function() {
      return this.contents[this.current];
    };

    StateMachineBox.prototype.draw = function() {
      var action, b, body, button, buttons, content, headlineDiv, idx, j, lastColor, len, self;
      if (this.constructor.MODE === this.constructor.MODES.SINGLE && (this.constructor.getActive() != null)) {
        console.warn("Popup::draw: tried to draw more than 1 popup but mode is set to 'single'!");
        return this;
      }
      self = this;
      if (this.headline) {
        headlineDiv = "<div class=\"header companyBGColor\">\n    <div class=\"headline noselect\">" + this.headline + "</div>\n</div>";
      } else {
        headlineDiv = "";
      }
      this.div.empty().append("<div class=\"content\">\n    <div class=\"close\" />\n    <div class=\"loader\" />\n    " + headlineDiv + "\n    <div class=\"bodyWrapper\" />\n    <div class=\"navigation\" />\n    <div class=\"footer\" />\n</div>");
      this.div.find(".overlay, .close").click(function() {
        self.fireAction(self.closeButtonAction);
        return true;
      });
      this.div.mousedown(function() {
        self._setAsActive();
        return true;
      });
      this.navigation = this.div.find(".navigation");
      this.loader = this.div.find(".loader");
      this.footer = this.div.find(".footer");
      buttons = this.options.buttons || [];
      for (idx = j = 0, len = buttons.length; j < len; idx = ++j) {
        button = buttons[idx];
        if (!(button != null)) {
          continue;
        }
        action = null;
        if (typeof button === "string") {
          b = button.toUpperCase();
          button = this.constructor.BUTTONS[b];
          action = this.constructor.ACTIONS[this.constructor.BUTTON_ACTIONS[b]];
        } else if ((button.button != null) && (button.action != null)) {
          b = button;
          button = this.constructor.BUTTONS[b.button.toUpperCase()];
          action = this.constructor.ACTIONS[b.action.toUpperCase()];
        } else {
          console.warn("Invalid button configuration for Popup!");
          continue;
        }
        if (action != null) {
          button = $(button);
          lastColor = this.constructor.BUTTON_COLORS[idx];
          button.css({
            "background-color": lastColor
          });
          (function(action) {
            return button.click(function() {
              action.call(self);
              return true;
            });
          })(action);
          this.footer.append(button);
        }
      }
      this.footer.css("background-color", lastColor);
      self = this;
      this.navigation.addClass("hidden");
      this.init();
      content = this.contents[this.current];
      if (content == null) {
        throw new Error("StatePopup::draw: No content found for '" + this.current + "'!");
      }
      body = $("<div class=\"body\" style=\"width: " + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + "px;\" />");
      body.append(content);
      this.bodyWrapper.append(body);
      if (this.constructor.MODE === this.constructor.MODES.MANY) {
        this.div.draggable({
          handle: ".header"
        }).addClass("draggable");
      } else if (this.constructor.MODE === this.constructor.MODES.SINGLE) {
        $(document.body).append(this.overlay.click(function() {
          self.fireAction("cancel");
          return true;
        }));
      }
      $(document.body).append(this.div);
      this._setAsActive();
      return this;
    };

    StateMachineBox.prototype.fireEvent = function() {
      var name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this[name] instanceof Function) {
        this[name].apply(this, params);
        return this;
      }
      console.warn("StateStatePopup::fireEvent: There is no event called '" + name + "'! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure(name);
      }
      return this;
    };

    StateMachineBox.prototype.next = function() {
      var event, foundEvents, j, len, ref;
      if (this.beforeNext instanceof Function && this.beforeNext() === false) {
        return false;
      }
      foundEvents = [];
      ref = this.stateMachineConfig.events;
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        if (event.from === this.current && event.name !== "back") {
          foundEvents.push(event);
        }
      }
      if (foundEvents.length === 1) {
        this.fireEvent(foundEvents.first.name);
        return this;
      }
      if (foundEvents.length === 0) {
        console.warn("StatePopup::next: There is no event for '" + this.current + "'! Can't go any further! Use onFailure() to catch that!");
        if (typeof this.onFailure === "function") {
          this.onFailure("next");
        }
        return this;
      }
      console.warn("StatePopup::next: More than 1 event for '" + this.current + "': [" + ((function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = foundEvents.length; k < len1; k++) {
          event = foundEvents[k];
          results.push(event.name);
        }
        return results;
      })()) + "]! Can't decide where to go! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure("next");
      }
      return this;
    };

    StateMachineBox.prototype.prev = function() {
      var e;
      if (this.beforePrev instanceof Function && this.beforePrev() === false) {
        return false;
      }
      try {
        this.back();
        return this;
      } catch (_error) {
        e = _error;
        console.warn("StatePopup::prev: Cannot go to 'prev' because no back route was defined! Define it with '{ name: 'back', from: 'prevState', to: 'returnState' }' ;) Use onFailure() to catch that!");
        console.warn(e);
        if (typeof this.onFailure === "function") {
          this.onFailure("prev");
        }
        return this;
      }
    };

    StateMachineBox.prototype.change = function(targetState) {
      var event, j, len, ref;
      if (this.beforeChange instanceof Function && this.beforeChange(idx) === false) {
        return false;
      }
      ref = this.stateMachineConfig.events;
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        if (!(event.from === this.current && event.to === targetState)) {
          continue;
        }
        this.fireEvent(event.name);
        if (this.onChange instanceof Function) {
          this.onChange.call(this, event.from, targetState);
        }
        return this;
      }
      console.warn("StatePopup::change: Cannot go to '" + targetState + "' from '" + this.current + "'! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure("change");
      }
      return this;
    };

    return StateMachineBox;

  })();

  SMB = (function(superClass) {
    extend(SMB, superClass);

    function SMB() {
      return SMB.__super__.constructor.apply(this, arguments);
    }

    return SMB;

  })(StateMachineBox);

}).call(this);
