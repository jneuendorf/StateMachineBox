// Generated by CoffeeScript 1.9.3

/**
* @class StateMachineBox
*
* @constructor
*
*
 */

(function() {
  var SMB,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.StateMachineBox = (function() {
    StateMachineBox.MODES = {
      SINGLE: "single",
      MANY: "many"
    };

    StateMachineBox.MODE = StateMachineBox.MODES.SINGLE;

    StateMachineBox.FADE_TIME = 180;

    StateMachineBox.DEFAULT_CSS_CLASS = "default";

    StateMachineBox.BUTTON_ACTIONS = {
      OK: "CLOSE",
      CANCEL: "CANCEL",
      NEXT: "NEXT",
      PREV: "PREV"
    };

    StateMachineBox.BUTTONS = {
      OK: "<div class=\"button ok\">ok</div>",
      CANCEL: "<div class=\"button cancel\">cancel</div>",
      NEXT: "<div class=\"button next\">next</div>",
      PREV: "<div class=\"button prev\">prev</div>"
    };

    StateMachineBox.ACTIONS = {
      CLOSE: function() {
        return this.close();
      },
      OK: function() {
        this.close(true);
        if (this.onOk instanceof Function) {
          this.onOk();
        }
        return this;
      },
      CANCEL: function() {
        this.close(true);
        if (this.onCancel instanceof Function) {
          this.onCancel();
        }
        return this;
      },
      CHANGE: function(idx) {
        return this.change(idx);
      },
      NEXT: function() {
        return this.next();
      },
      PREV: function() {
        return this.prev();
      }
    };

    StateMachineBox.BUTTON_COLORS = ["#222222", "#9FA39F", "#B9BCB9", "#D3D5D3"];

    StateMachineBox._popups = [];

    StateMachineBox._activePopup = null;

    if (DEBUG) {
      StateMachineBox._localeKeys = ["ok", "cancel", "next", "prev"];
      StateMachineBox._languageKeys = ["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"];
    }

    StateMachineBox._$cache = {
      popup: $("<div class=\"popup\">\n    <div class=\"content\">\n        <div class=\"close\" />\n        <div class=\"loader\" />\n        <div class=\"header\">\n            <div class=\"headline\" />\n        </div>\n        <div class=\"bodyWrapper\" />\n        <div class=\"navigation\" />\n        <div class=\"footer\" />\n    </div>\n</div>"),
      overlay: $("<div class=\"popup overlay\" />")
    };

    StateMachineBox.locale = {};

    StateMachineBox.init = function() {
      this.setLocale("en", {
        ok: "ok",
        cancel: "cancel",
        next: "next",
        prev: "previous"
      });
      this.setLocale("de", {
        ok: "ok",
        cancel: "abbrechen",
        next: "weiter",
        prev: "zur√ºck"
      });
      return this;
    };

    StateMachineBox.getTopMost = function() {
      var divs, j, len, popup, popups;
      popups = this._popups;
      divs = $();
      for (j = 0, len = popups.length; j < len; j++) {
        popup = popups[j];
        divs = divs.add(popup.div);
      }
      return popups[divs.index(divs.filter(":visible:last"))] || null;
    };

    StateMachineBox._setActive = function(popup) {
      this._activePopup = popup;
      return this;
    };

    StateMachineBox.getActive = function() {
      return this._activePopup || this.getTopMost();
    };

    StateMachineBox.setLocale = function(language, values, redraw) {
      var j, k, key, l, len, len1, len2, popup, ref, ref1, ref2;
      if (redraw == null) {
        redraw = true;
      }
      if (DEBUG) {
        if (indexOf.call(this._languageKeys, language) >= 0) {
          ref = this._localeKeys;
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            if (values[key] == null) {
              throw new Error("StateMachineBox.setLocale: Missing at least 1 key '" + key + "' for locale settings!");
            }
          }
          this.locale[language] = values;
          ref1 = this._popups;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            popup = ref1[k];
            popup.redraw();
          }
          return this;
        }
        throw new Error("StateMachineBox.setLocale: Invalid language '" + language + "' given!");
      }
      this.locale[language] = values;
      ref2 = this._popups;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        popup = ref2[l];
        popup.redraw();
      }
      return this;
    };

    StateMachineBox.getLocale = function(language, key) {
      var ref;
      if (DEBUG) {
        if (((ref = this.locale[language]) != null ? ref[key] : void 0) != null) {
          return this.locale[language][key];
        }
        if ((key == null) && (this.locale[language] != null)) {
          console.info("StateMachineBox.getLocale: No key given. Returning all keys for '" + language + "'.");
          return this.locale[language];
        }
        throw new Error("StateMachineBox.getLocale: language '" + language + "' not set or key '" + key + "' not found!");
      }
      if (key != null) {
        return this.locale[language][key] || null;
      }
      return this.locale[language];
    };

    StateMachineBox.registerPopup = function(popup) {
      if (indexOf.call(this._popups, popup) < 0) {
        this._popups.push(popup);
      }
      return this;
    };

    StateMachineBox.unregisterPopup = function(popup) {
      var i, p;
      this._popups = (function() {
        var j, len, ref, results;
        ref = this._popups;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          p = ref[i];
          if (p !== popup) {
            results.push(p);
          }
        }
        return results;
      }).call(this);
      return this;
    };

    StateMachineBox["new"] = function(stateMachineConfig, headline, options) {
      if (options == null) {
        options = {};
      }
      return new this(stateMachineConfig, headline, options);
    };

    function StateMachineBox(stateMachineConfig, headline, options) {
      var callback, callbackName, event, j, k, len, len1, ref, ref1, ref2, self;
      if (options == null) {
        options = {};
      }
      if (DEBUG) {
        if ((stateMachineConfig == null) || (stateMachineConfig.events == null)) {
          throw new Error("StateMachineBox::constructor: No (valid) state machine configuration given!");
        }
        ref = stateMachineConfig.events;
        for (j = 0, len = ref.length; j < len; j++) {
          event = ref[j];
          if (this[event.name] != null) {
            throw new Error("StateMachineBox::constructor: Trying to create event '" + event.name + "' but that property already exists in popup!!");
          }
        }
        ref1 = stateMachineConfig.callbacks;
        for (callbackName in ref1) {
          callback = ref1[callbackName];
          if (this[callbackName] != null) {
            throw new Error("StateMachineBox::constructor: Trying to create callback '" + callbackName + "' but that property already exists in popup!!");
          }
        }
      }
      this.headline = headline;
      this.options = options;
      this.closeButtonAction = options.closeButtonAction || "close";
      this.onClose = options.onClose;
      this.onOk = options.onOk;
      this.onCancel = options.onCancel;
      this.onNext = options.onNext;
      this.onPrev = options.onPrev;
      this.onChange = options.onChange;
      this.beforeClose = options.beforeClose;
      this.beforeNext = options.beforeNext;
      this.beforePrev = options.beforePrev;
      this.beforeChange = options.beforeChange;
      this.onFailure = options.onFailure;
      this.theme = options.theme || "default";
      this.locale = options.locale || "en";
      this.showNavigation = options.showNavigation || false;
      this.container = options.container || $(document.body);
      this.data = {};
      this.div = this.constructor._$cache.popup.clone();
      this.overlay = this.constructor._$cache.overlay.clone();
      if ((options.width != null) && (options.height != null)) {
        this.div.css({
          width: options.width,
          height: options.height
        });
      }
      this.loader = null;
      this.bodyWidth = parseFloat(this.options.width) || 800;
      this.bodyPadding = {
        top: 10,
        right: 40,
        bottom: 10,
        left: 40
      };
      this._active = false;
      stateMachineConfig.target = this;
      this.stateMachineConfig = stateMachineConfig;
      this.bodyWrapper = null;
      this.contents = {};
      ref2 = stateMachineConfig.events;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        event = ref2[k];
        if (event.content != null) {
          this.contents[event.to] = event.content;
        }
      }
      self = this;
      if (stateMachineConfig.callbacks == null) {
        stateMachineConfig.callbacks = {};
      }
      stateMachineConfig.callbacks.onenterstate = function() {
        var event, from, params, to;
        event = arguments[0], from = arguments[1], to = arguments[2], params = 4 <= arguments.length ? slice.call(arguments, 3) : [];
        console.log("onenterstate", arguments);
        if (self.beforeChange instanceof Function && self.beforeChange(to) === false) {
          return false;
        }
        self.changeContent(event, from, to);
        return true;
      };
      StateMachine.create(stateMachineConfig);
      this.constructor.registerPopup(this);
    }

    StateMachineBox.prototype._setAsActive = function() {
      this.constructor._setActive(this);
      return this;
    };

    StateMachineBox.prototype.show = function(callback) {
      this.div.fadeIn(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.hide = function(callback) {
      this.div.fadeOut(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.showOverlay = function(callback) {
      this.overlay.fadeIn(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.hideOverlay = function(callback) {
      this.overlay.fadeOut(FADE_TIME, callback);
      return this;
    };

    StateMachineBox.prototype.showLoader = function() {
      this.loader.fadeIn(FADE_TIME);
      return this;
    };

    StateMachineBox.prototype.hideLoader = function() {
      this.loader.fadeOut(FADE_TIME);
      return this;
    };

    StateMachineBox.prototype.fireAction = function() {
      var action, name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      name = name.toUpperCase();
      if ((action = this.constructor.ACTIONS[name]) != null) {
        return action.apply(this, params);
      }
      throw new Error("Popup::fireAction: No action with name '" + name + "' found!");
    };

    StateMachineBox.prototype.close = function(ignoreCallback) {
      var self;
      if (ignoreCallback == null) {
        ignoreCallback = false;
      }
      if (!ignoreCallback && this.beforeClose instanceof Function && this.beforeClose() === false) {
        return false;
      }
      self = this;
      this.hide(function() {
        self.div.remove();
        return true;
      });
      this.hideOverlay(function() {
        self.overlay.remove();
        return true;
      });
      this.constructor.unregisterPopup(this);
      if (!ignoreCallback) {
        if (typeof this.onClose === "function") {
          this.onClose();
        }
      }
      return this;
    };

    StateMachineBox.prototype.remove = function() {
      return this.close.apply(this, arguments);
    };

    StateMachineBox.prototype.changeContent = function(event, from, to) {
      var body, content;
      body = $("<div class=\"body\" style=\"width: " + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + "px;\" />");
      content = this.contents[to];
      if (content == null) {
        throw new Error("StateMachineBox::changeContent: No content given for '" + to + "'!");
      }
      if (this.bodyWrapper == null) {
        this.bodyWrapper = this.div.find(".bodyWrapper");
      }
      body.append(content);
      if (event === "back") {
        this.bodyWrapper.prepend(body).css("margin-left", "-" + this.bodyWidth + "px").animate({
          "margin-left": "0px"
        }, 400, "swing", function() {
          $(this).children().eq(1).detach();
          return true;
        });
      } else if (from !== "none") {
        this.bodyWrapper.append(body).animate({
          "margin-left": "-" + this.bodyWidth + "px"
        }, 400, "swing", function() {
          $(this).children().eq(0).detach();
          $(this).css("margin-left", "0px");
          return true;
        });
      }
      return this;
    };

    StateMachineBox.prototype.currentContent = function() {
      return this.contents[this.current];
    };

    StateMachineBox.prototype.draw = function() {
      var action, b, body, button, buttons, content, headlineDiv, idx, j, lastColor, len, self;
      if (this.constructor.MODE === this.constructor.MODES.SINGLE && (this.constructor.getActive() != null)) {
        console.warn("Popup::draw: tried to draw more than 1 popup but mode is set to 'single'!");
        return this;
      }
      self = this;
      if (this.headline) {
        headlineDiv = "<div class=\"header companyBGColor\">\n    <div class=\"headline noselect\">" + this.headline + "</div>\n</div>";
      } else {
        headlineDiv = "";
      }
      this.div.empty().append("<div class=\"content\">\n    <div class=\"close\" />\n    <div class=\"loader\" />\n    " + headlineDiv + "\n    <div class=\"bodyWrapper\" />\n    <div class=\"navigation\" />\n    <div class=\"footer\" />\n</div>");
      this.div.find(".overlay, .close").click(function() {
        self.fireAction(self.closeButtonAction);
        return true;
      });
      this.div.mousedown(function() {
        self._setAsActive();
        return true;
      });
      this.navigation = this.div.find(".navigation");
      this.loader = this.div.find(".loader");
      this.footer = this.div.find(".footer");
      buttons = this.options.buttons || [];
      for (idx = j = 0, len = buttons.length; j < len; idx = ++j) {
        button = buttons[idx];
        if (!(button != null)) {
          continue;
        }
        action = null;
        if (typeof button === "string") {
          b = button.toUpperCase();
          button = this.constructor.BUTTONS[b];
          action = this.constructor.ACTIONS[this.constructor.BUTTON_ACTIONS[b]];
        } else if ((button.button != null) && (button.action != null)) {
          b = button;
          button = this.constructor.BUTTONS[b.button.toUpperCase()];
          action = this.constructor.ACTIONS[b.action.toUpperCase()];
        } else {
          console.warn("Invalid button configuration for Popup!");
          continue;
        }
        if (action != null) {
          button = $(button);
          lastColor = this.constructor.BUTTON_COLORS[idx];
          button.css({
            "background-color": lastColor
          });
          (function(action) {
            return button.click(function() {
              action.call(self);
              return true;
            });
          })(action);
          this.footer.append(button);
        }
      }
      this.footer.css("background-color", lastColor);
      self = this;
      if (!this.showNavigation) {
        this.navigation.addClass("hidden");
      }
      this.init();
      content = this.contents[this.current];
      if (content == null) {
        throw new Error("StateMachineBox::draw: No content found for '" + this.current + "'!");
      }
      body = $("<div class=\"body\" style=\"width: " + (this.bodyWidth - this.bodyPadding.left - this.bodyPadding.right) + "px;\" />");
      body.append(content);
      this.bodyWrapper.append(body);
      if (this.constructor.MODE === this.constructor.MODES.MANY) {
        this.div.draggable({
          handle: ".header"
        }).addClass("draggable");
      } else if (this.constructor.MODE === this.constructor.MODES.SINGLE) {
        this.container.append(this.overlay.click(function() {
          self.fireAction("cancel");
          return true;
        }));
      }
      this.container.append(this.div);
      this._setAsActive();
      return this;
    };

    StateMachineBox.prototype.redraw = function() {
      return this;
    };

    StateMachineBox.prototype.fireEvent = function() {
      var name, params;
      name = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this[name] instanceof Function) {
        this[name].apply(this, params);
        return this;
      }
      console.warn("StateStatePopup::fireEvent: There is no event called '" + name + "'! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure(name);
      }
      return this;
    };

    StateMachineBox.prototype.next = function() {
      var event, foundEvents, j, len, ref;
      if (this.beforeNext instanceof Function && this.beforeNext() === false) {
        return false;
      }
      foundEvents = [];
      ref = this.stateMachineConfig.events;
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        if (event.from === this.current && event.name !== "back") {
          foundEvents.push(event);
        }
      }
      if (foundEvents.length === 1) {
        this.fireEvent(foundEvents.first.name);
        return this;
      }
      if (foundEvents.length === 0) {
        console.warn("StateMachineBox::next: There is no event for '" + this.current + "'! Can't go any further! Use onFailure() to catch that!");
        if (typeof this.onFailure === "function") {
          this.onFailure("next");
        }
        return this;
      }
      console.warn("StateMachineBox::next: More than 1 event for '" + this.current + "': [" + ((function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = foundEvents.length; k < len1; k++) {
          event = foundEvents[k];
          results.push(event.name);
        }
        return results;
      })()) + "]! Can't decide where to go! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure("next");
      }
      return this;
    };

    StateMachineBox.prototype.prev = function() {
      var e;
      if (this.beforePrev instanceof Function && this.beforePrev() === false) {
        return false;
      }
      try {
        this.back();
        return this;
      } catch (_error) {
        e = _error;
        console.warn("StateMachineBox::prev: Cannot go to 'prev' because no back route was defined! Define it with '{ name: 'back', from: 'prevState', to: 'returnState' }' ;) Use onFailure() to catch that!");
        console.warn(e);
        if (typeof this.onFailure === "function") {
          this.onFailure("prev");
        }
        return this;
      }
    };

    StateMachineBox.prototype.change = function(targetState) {
      var event, j, len, ref;
      if (this.beforeChange instanceof Function && this.beforeChange(idx) === false) {
        return false;
      }
      ref = this.stateMachineConfig.events;
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        if (!(event.from === this.current && event.to === targetState)) {
          continue;
        }
        this.fireEvent(event.name);
        if (this.onChange instanceof Function) {
          this.onChange.call(this, event.from, targetState);
        }
        return this;
      }
      console.warn("StateMachineBox::change: Cannot go to '" + targetState + "' from '" + this.current + "'! Use onFailure() to catch that!");
      if (typeof this.onFailure === "function") {
        this.onFailure("change");
      }
      return this;
    };

    return StateMachineBox;

  })();

  StateMachineBox.init();

  SMB = (function(superClass) {
    extend(SMB, superClass);

    function SMB() {
      return SMB.__super__.constructor.apply(this, arguments);
    }

    return SMB;

  })(StateMachineBox);

}).call(this);
